<!DOCTYPE html>
<html>
<head>
    <title>3D Business Card Preview</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #d8d8d8; /* 10% darker than #f0f0f0 */
        }
        canvas {
            display: block;
        }
        #card-container {
            /* No specific width/height needed */
        }
    </style>
</head>
<body>
    <div id="card-container"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>
    <script>
        // 1. Set up the scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('card-container').appendChild(renderer.domElement);
        renderer.setClearColor(0xd8d8d8); // Ensure Three.js background matches
        // renderer.setClearColor(0xf0f0f0); // Original color

        // 2. Add Orbit Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 1;
        controls.maxDistance = 10;

        // --- Gradient Functions ---
        function createDiagonalGradientTexture(colors, width, height, inverted = false) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            const startX = inverted ? width : 0;
            const startY = inverted ? 0 : height;
            const endX = inverted ? 0 : width;
            const endY = inverted ? height : 0;
            const gradient = ctx.createLinearGradient(startX, startY, endX, endY); // Diagonal gradient
            colors.forEach((color, index) => {
                gradient.addColorStop(index / (colors.length - 1), color);
            });
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
            return new THREE.CanvasTexture(canvas);
        }

        function createHorizontalGradientTexture(colors, width, height, inverted = false) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            const startX = inverted ? width : 0;
            const endX = inverted ? 0 : width;
            const gradient = ctx.createLinearGradient(startX, 0, endX, 0); // Horizontal gradient
            colors.forEach((color, index) => {
                gradient.addColorStop(index / (colors.length - 1), color);
            });
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
            return new THREE.CanvasTexture(canvas);
        }

        // 3. Load Textures and Create Geometry and Materials
        const textureLoader = new THREE.TextureLoader();
        textureLoader.load('./front.png', function (frontTexture) {
            const cardAspectRatio = frontTexture.image.width / frontTexture.image.height;
            let cardHeight = 3.5;
            let cardWidth = cardHeight * cardAspectRatio;

            // Make the card 20% smaller
            cardHeight *= 0.8;
            cardWidth *= 0.8;

            const cardDepth = 0.05;

            const cardGeometry = new THREE.BoxGeometry(cardWidth, cardHeight, cardDepth);

            textureLoader.load('./back.png', function (backTexture) {
                // Texture Filtering for sharpness
                frontTexture.minFilter = THREE.LinearFilter;
                frontTexture.magFilter = THREE.LinearFilter;
                backTexture.minFilter = THREE.LinearFilter;
                backTexture.magFilter = THREE.LinearFilter;

                // --- Create Gradient Textures ---
                const gradientColors = ['#6300ff', '#9505bc', '#e41d4b', '#fa7638', '#ffb921'];
                const diagonalGradientTexture = createDiagonalGradientTexture(gradientColors, 200, 10);
                const horizontalGradientTexture = createHorizontalGradientTexture(gradientColors, 200, 10);
                const invertedHorizontalGradientTexture = createHorizontalGradientTexture([...gradientColors].reverse(), 200, 10);
                const invertedDiagonalGradientTexture = createDiagonalGradientTexture(gradientColors, 200, 10, true);

                diagonalGradientTexture.needsUpdate = true;
                horizontalGradientTexture.needsUpdate = true;
                invertedHorizontalGradientTexture.needsUpdate = true;
                invertedDiagonalGradientTexture.needsUpdate = true;

                // 5. Create Materials - Applying gradients with individual control
                const materials = [
                    new THREE.MeshBasicMaterial({ map: invertedDiagonalGradientTexture }), // Right - Inverted
                    new THREE.MeshBasicMaterial({ map: diagonalGradientTexture }), // Left
                    new THREE.MeshBasicMaterial({ map: horizontalGradientTexture }), // Top
                    new THREE.MeshBasicMaterial({ map: invertedHorizontalGradientTexture }), // Bottom - Inverted
                    new THREE.MeshBasicMaterial({ map: frontTexture }),             // Front
                    new THREE.MeshBasicMaterial({ map: backTexture })              // Back
                ];

                // Rotate the gradient texture for right and left faces
                materials[0].map.rotation = -Math.PI / 2;   // Right face (rotate -90 degrees)
                materials[0].map.center.set(0.5, 0.5);     // Set rotation center
                materials[1].map.rotation = -Math.PI / 2;  // Left face (rotate -90 degrees)
                materials[1].map.center.set(0.5, 0.5);     // Set rotation center

                const card = new THREE.Mesh(cardGeometry, materials);
                scene.add(card);

                // Create the second card
                const card2 = new THREE.Mesh(cardGeometry, materials);
                card2.position.y = cardHeight + 0.5; // Position above the first card (adjust spacing)
                scene.add(card2);

                // Create the third card
                const card3 = new THREE.Mesh(cardGeometry, materials);
                card3.position.y = -(cardHeight + 0.5); // Position below the first card (adjust spacing)
                scene.add(card3);

                // 8. Animation Loop
                let rotationSpeed = -0.01; // Negative for opposite direction
                rotationSpeed *= 0.7;   // Slow down by 30%

                function animate() {
                    requestAnimationFrame(animate);
                    card.rotation.y += rotationSpeed;
                    card2.rotation.y += rotationSpeed;
                    card3.rotation.y += rotationSpeed;
                    controls.update();
                    renderer.render(scene, camera);
                }
                animate();
            });
        });

        // 6. Position the Camera
        camera.position.z = 8; // Moved the camera back

        // 7. Add Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(1, 1, 2);
        scene.add(directionalLight);

        // 9. Handle Window Resizing
        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>